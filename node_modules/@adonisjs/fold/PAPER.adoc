= Ioc container paper

NOTE: This document outlines the working of the IoC container used by AdonisJs. This package is independent of the framework and can be used anywhere. +
After reading this paper you will understand the inner workings of this package.


NOTE: Dependency Injection is common in some language like *Java*. Php framework *Laravel* also uses IoC container for delivering seamless experience.

== Terms
1. *Ioc container* - The object that holds dependencies and thier unique keys.
2. *Bindings* - The key/value pair inside the IoC container object is known as a binding.
3. *Factory function* - The function that is called in order to resolve a dependency.
4. *Service providers* - Lifecycle hooks to defined and boot dependencies.
5. *Aliases* - Giving short names for file system paths.
6. *This package* - Reference to link:http://github.com/poppinss/adonis-fold/[adonis-fold]

== Expected to work with
This package will only work with Node.js and never been tested in the browser. Also making it compatable with the browsers is out of the scope.

== Dependency management
The job of the IoC container is to manage dependencies inside memory with a unique key, which is used to resolve them later. For example:

[source, js]
----
const ioc = {
  moment: function () {
    return require('moment')
  }
}
----

Now everytime you want the reference of the `moment` library, you fetch it from the `ioc object` instead of requiring it directly.

[source, js]
----
const comment = ioc.moment()
----

=== Benefits.
1. It is decoupled from the file system, which means the `factory function` can return any value.
2. The power of Javascript is that it is a dynamic language and this approach gives you a chance to return dynamic values from the *factory functions*.
3. Easy to test, since overiding a value inside an object is easier than overriding a file on the file-system.

=== Drawbacks
1. *Not reproducable*, since factory functions have the power to return dynamic value, it is hard to say that return value will be same everytime.
2. *No static analysis* - Static analysis is hard, since values are known at runtime.
3. *Needs documentation*.

== Why you need it?
It is a fair question to ask. Every line of code comes with some cost.

The tradeoff of using IoC container have been explained in the *drawbacks* section. If you are building a simple system it is fine to stick `CommonJs` and require modules using the `require` keyword.

For a framework/eco-system like AdonisJs, it was fine to take these tradeoffs and ship better experience for users. Have you ever noticed how simple it is to consume a package in AdonisJs.

For example:

[source, js]
----
const Mail = use('Mail')
await Mail.send('...')
----

And the `Mail` binding will figure out how to create a new instance and use the config from the `Config` provider.

Also when testing you can call `Mail.fake()` and it will store emails in memory for assertions. Faking the in-memory mail object is way easier than faking it on the file-system.

== Write some code
Let's take the `Mail` binding as an example and create 2 versions of it. One with the *IoC container* and other without it. Also we are going to *self-implement the IoC container* in this example

=== Plain version

[source, shell]
----
└── config.js
└── packages
  ├── mail.js
----

1. We assume that `mail.js` is a 3rd party package.
2. `config.js` is the configuration file for our application. Which means `mail.js` doesn't know anything about the configuration.

.packages/mail.js
[source, js]
----
class Mail {
  constructor (config) {
    this.config = config
  }

  send () {
    // send email
  }
}

module.exports = Mail
----

.config.js
[source, js]
----
module.exports = {
  mail: {
    apiKey: '...',
    apiSecret: '...'
  }
}
----

.Usage
[source, js]
----
const config = require('./config')
const Mail = require('./packages/Mail')

const mailInstance = new Mail(config.mail)
mailInstance.send()
----

=== Key points to note
